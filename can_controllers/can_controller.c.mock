/**
 * Mock CAN Controller
 */
#include <stdio.h>
#include "can_controller.h"

reg(can_tx0_buf); reg(can_tx1_buf); reg(can_tx2_buf);
reg(can_rx0_buf); reg(can_rx1_buf);

bool is_can_busy;
bool should_can_receive_error;
bool was_can_setup;

static uint8_t _buffer[CAN_MESSAGE_SIZE+1];

static io_pin can_int_pin;
static io_pin can_cs_pin;


static void can_fake_message_received(void);


/**
 * Setup function
 */
void can_controller_setup(io_pin cs_pin, io_pin int_pin)
{
  is_can_busy = False;
  should_can_receive_error = False;
  was_can_setup = True;

  can_int_pin = int_pin;
  can_cs_pin = cs_pin;

  attachInterrupt(can_int_pin, can_fake_message_received);
  setRegisterBitHigh(p1_in, pinBit(int_pin));
}

/**
 * Test Transmission
 */
bool can_controller_transmit(can_message* msg)
{
  uint8_t i;
  uint16_t* ptr = NULL;

  if (is_can_busy)  // Allows testing of this functionality in the CAN drivers
    return Failure;

  // Put message into buffer
  _buffer[0] = rightShift(msg->address, 3);
  _buffer[1] = leftShift(msg->address, 5);
  _buffer[2] = NULL;
  _buffer[3] = NULL;
  _buffer[4] = 8;
  for (i = 0; i < 8; i++)
    _buffer[5+i] = msg->data.data_u8[i];

  // Set into the txbuf
  ptr = can_tx0_buf;
  for (i = 0; i < CAN_MESSAGE_SIZE; i++)
    *ptr++ = _buffer[i];

  return True;
}

/**
 * Test polling
 */
void can_controller_poll(void)
{
  if (isPinLow(can_int_pin))
  {
    can_fake_message_received();
  }
}


void can_fake_message_received(void)
{
  uint8_t i;

  // Put message into can receive queue
  can_message* msg = _can_get_next_receive_ptr();
  msg->address = 0x440;
  msg->status = CAN_OK;
  for (i = 0; i < 8; i++)
    msg->data.data_u8[i] = 7-i;

  // Allows for testing of error messages
  if (should_can_receive_error)
    msg->status = CAN_ERROR;
}