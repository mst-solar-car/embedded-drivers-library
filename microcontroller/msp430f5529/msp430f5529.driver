  /**
 * MSP430F5529
 *
 * Authors: Michael Rouse
 */

#include "../fixture.h"
#include "../interface.h"
#include "../../datatypes.h"



/* Configures a SPI Bus */
void __microcontroller_spi_setup(spi_bus bus, io_pin mosi, io_pin miso, io_pin sck)
{
#ifndef UNIT_TEST
  switch (bus) {
      case SPI_BUS_1:
        // UCA0
        UCA0CTL1  = UCSWRST;	//Hold the device in a reset state while we configure
        UCA0CTL0  = 0x69;		//SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCA0CTL1 |= UCSSEL_3;		//SPI clock (BRCLK) source = SMCLK
        UCA0BR1	  = 0x00;		//Set the high bit of the baud rate generator
        UCA0BR0	  = 0x14;		//Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCA0IE   |= 0x04;		//Enable interrupts
        UCA0CTL1 &= ~UCSWRST;	//Release the bus from reset state
        break;

      case SPI_BUS_2:
        // UCA1
        UCA1CTL1  = UCSWRST;	//Hold the device in a reset state while we configure
        UCA1CTL0  = 0x69;		//SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCA1CTL1 |= UCSSEL_3;		//SPI clock (BRCLK) source = SMCLK
        UCA1BR1	  = 0x00;		//Set the high bit of the baud rate generator
        UCA1BR0	  = 0x14;		//Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCA1IE   |= 0x04;		//Enable interrupts
        UCA1CTL1 &= ~UCSWRST;	//Release the bus from reset state
        break;

      case SPI_BUS_3:
        // UCB0
        UCB0CTL1  = UCSWRST;	//Hold the device in a reset state while we configure
        UCB0CTL0  = 0x69;		//SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCB0CTL1 |= UCSSEL_3;		//SPI clock (BRCLK) source = SMCLK
        UCB0BR1	  = 0x00;		//Set the high bit of the baud rate generator
        UCB0BR0	  = 0x14;		//Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCB0IE   |= 0x04;		//Enable interrupts
        UCB0CTL1 &= ~UCSWRST;	//Release the bus from reset state
        break;

      case SPI_BUS_4:
        // UCB1
        UCB1CTL1  = UCSWRST;    //Hold the device in a reset state while we configure
        UCB1CTL0  = 0x69;       //SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCB1CTL1 |= UCSSEL_3;       //SPI clock (BRCLK) source = SMCLK
        UCB1BR1   = 0x00;       //Set the high bit of the baud rate generator
        UCB1BR0   = 0x14;       //Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCB1IE   |= 0x04;     //Enable interrupts
        UCB1CTL1 &= ~UCSWRST;   //Release the bus from reset state
        break;
  }
#endif
}


/* Transmits data over a SPI bus */
uint8_t __microcontroller_spi_transmit(spi_bus bus, void* data, uint8_t size)
{
  uint8_t* d = (uint8_t*)data;
#ifndef UNIT_TEST
  switch (bus) {
    case SPI_BUS_1:
      // UCA0
      while ((UCA0STAT & UCIDLE) != 0);
      UCA0TXBUF = *d;
      while ((UCA0STAT & UCBUSY) != 0);
      return UCA0RXBUF;

    case SPI_BUS_2:
      // UCA1
      while ((UCA1STAT & UCIDLE) != 0);
      UCA1TXBUF = *d;
      while ((UCA1STAT & UCBUSY) != 0);
      return UCA1RXBUF;

    case SPI_BUS_3:
      // UCB0
      while ((UCB0STAT & UCIDLE) != 0);
      UCB0TXBUF = *d;
      while ((UCB0STAT & UCBUSY) != 0);
      return UCB0RXBUF;

    case SPI_BUS_4:
      // UCB1
      while ((UCB1STAT & UCIDLE) != 0);
      UCB1TXBUF = *d;
      while ((UCB1STAT & UCBUSY) != 0);
      return UCB1RXBUF;
  }
#endif
  return 0;
}








/* Microcontroller Initialization */
void microcontroller_initialization(void)
{
  REGISTER(WDTCTL) = (0x5A00) + (0x0080);

  /* Set all GPIO Ports to Output and Low */
  *(port_map[PORT1].dir_reg) = Output;   *(port_map[PORT1].out_reg) = Low;
  *(port_map[PORT2].dir_reg) = Output;   *(port_map[PORT2].out_reg) = Low;
  *(port_map[PORT3].dir_reg) = Output;   *(port_map[PORT3].out_reg) = Low;
  *(port_map[PORT4].dir_reg) = Output;   *(port_map[PORT4].out_reg) = Low;
  *(port_map[PORT5].dir_reg) = Output;   *(port_map[PORT5].out_reg) = Low;
  *(port_map[PORT6].dir_reg) = Output;   *(port_map[PORT6].out_reg) = Low;
  *(port_map[PORT7].dir_reg) = Output;   *(port_map[PORT7].out_reg) = Low;
  *(port_map[PORT8].dir_reg) = Output;   *(port_map[PORT8].out_reg) = Low;


  /* Set all GPIO ports to Output and Low *
  *(dir_registers[PORT1]) = Output; *(out_registers[PORT1]) = Low;
  *(dir_registers[PORT2]) = Output; *(out_registers[PORT2]) = Low;
  *(dir_registers[PORT3]) = Output; *(out_registers[PORT3]) = Low;
  *(dir_registers[PORT4]) = Output; *(out_registers[PORT4]) = Low;
  *(dir_registers[PORT5]) = Output; *(out_registers[PORT5]) = Low;
  *(dir_registers[PORT6]) = Output; *(out_registers[PORT6]) = Low;
  *(dir_registers[PORT7]) = Output; *(out_registers[PORT7]) = Low;
  *(dir_registers[PORT8]) = Output; *(out_registers[PORT8]) = Low;*/
}