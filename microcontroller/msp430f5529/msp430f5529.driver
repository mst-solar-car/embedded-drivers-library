  /**
 * MSP430F5529
 *
 * Authors: Michael Rouse
 */
#ifndef UNIT_TEST
#include <msp430f5529.h>
#endif
#include "../fixture.h"
#include "../interface.h"
#include "../../datatypes.h"


/* Used by the Pin Control Driver for controlling pins */
void __microcontroller_set_pin_mode(io_pin pin, pin_mode mode)
{
  pin_info_t _pin = GetPinInfo(pin);

  /* Can't configure something that is invalid */
  if (!IsValidPinInfo(_pin) || _pin.dir_reg == NO_REGISTER)
    return;

  if (mode == Input)
    *(_pin.dir_reg) &= ~(_pin.bit);
  else
    *(_pin.dir_reg) |= _pin.bit;
}


/* Used by the Pin Control Driver for controlling pins */
void __microcontroller_set_pin_level(io_pin pin, pin_level level)
{
  pin_info_t _pin = GetPinInfo(pin);

  if (!IsValidPinInfo(_pin) || _pin.out_reg == NO_REGISTER)
    return;

  if (level == Low)
    *(_pin.out_reg) &= ~(_pin.bit);
  else
    *(_pin.out_reg) |= _pin.bit;
}


/* Used by the Pin Control Driver for controlling pins */
pin_level __microcontroller_read_pin(io_pin pin)
{
  pin_info_t _pin = GetPinInfo(pin);

  if (!IsValidPinInfo(_pin) || _pin.in_reg == NO_REGISTER)
    return Low;

  return (*(_pin.in_reg) & _pin.bit);
}


/* Configures a SPI Bus */
void __microcontroller_spi_setup(spi_bus bus, io_pin mosi, io_pin miso, io_pin sck)
{
#ifndef UNIT_TEST
  switch (bus) {
      case SPI_BUS_1:
        // UCA0
        UCA0CTL1  = UCSWRST;	//Hold the device in a reset state while we configure
        UCA0CTL0  = 0x69;		//SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCA0CTL1 |= UCSSEL_3;		//SPI clock (BRCLK) source = SMCLK
        UCA0BR1	  = 0x00;		//Set the high bit of the baud rate generator
        UCA0BR0	  = 0x14;		//Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCA0IE   |= 0x04;		//Enable interrupts
        UCA0CTL1 &= ~UCSWRST;	//Release the bus from reset state
        break;

      case SPI_BUS_2:
        // UCA1
        UCA1CTL1  = UCSWRST;	//Hold the device in a reset state while we configure
        UCA1CTL0  = 0x69;		//SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCA1CTL1 |= UCSSEL_3;		//SPI clock (BRCLK) source = SMCLK
        UCA1BR1	  = 0x00;		//Set the high bit of the baud rate generator
        UCA1BR0	  = 0x14;		//Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCA1IE   |= 0x04;		//Enable interrupts
        UCA1CTL1 &= ~UCSWRST;	//Release the bus from reset state
        break;

      case SPI_BUS_3:
        // UCB0
        UCB0CTL1  = UCSWRST;	//Hold the device in a reset state while we configure
        UCB0CTL0  = 0x69;		//SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCB0CTL1 |= UCSSEL_3;		//SPI clock (BRCLK) source = SMCLK
        UCB0BR1	  = 0x00;		//Set the high bit of the baud rate generator
        UCB0BR0	  = 0x14;		//Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCB0IE   |= 0x04;		//Enable interrupts
        UCB0CTL1 &= ~UCSWRST;	//Release the bus from reset state
        break;

      case SPI_BUS_4:
        // UCB1
        UCB1CTL1  = UCSWRST;    //Hold the device in a reset state while we configure
        UCB1CTL0  = 0x69;       //SPI mode 11, MSB first, 8 bit data, 3pin master synchronous mode
        UCB1CTL1 |= UCSSEL_3;       //SPI clock (BRCLK) source = SMCLK
        UCB1BR1   = 0x00;       //Set the high bit of the baud rate generator
        UCB1BR0   = 0x14;       //Set the low bit of the baud rate generator (SMCLK / 20 == 1MHz SPI)
        //UCB1IE   |= 0x04;     //Enable interrupts
        UCB1CTL1 &= ~UCSWRST;   //Release the bus from reset state
        break;
  }
#endif
}


/* Transmits data over a SPI bus */
uint8_t __microcontroller_spi_transmit(spi_bus bus, void* data, uint8_t size)
{
  uint8_t* d = (uint8_t*)data;
#ifndef UNIT_TEST
  switch (bus) {
    case SPI_BUS_1:
      // UCA0
      while ((UCA0STAT & UCIDLE) != 0);
      UCA0TXBUF = *d;
      while ((UCA0STAT & UCBUSY) != 0);
      return UCA0RXBUF;

    case SPI_BUS_2:
      // UCA1
      while ((UCA1STAT & UCIDLE) != 0);
      UCA1TXBUF = *d;
      while ((UCA1STAT & UCBUSY) != 0);
      return UCA1RXBUF;

    case SPI_BUS_3:
      // UCB0
      while ((UCB0STAT & UCIDLE) != 0);
      UCB0TXBUF = *d;
      while ((UCB0STAT & UCBUSY) != 0);
      return UCB0RXBUF;

    case SPI_BUS_4:
      // UCB1
      while ((UCB1STAT & UCIDLE) != 0);
      UCB1TXBUF = *d;
      while ((UCB1STAT & UCBUSY) != 0);
      return UCB1RXBUF;
  }
#endif
  return 0;
}








/* Microcontroller Initialization */
void microcontroller_initialization(void)
{
  /* Set all GPIO ports to Output and Low */
  *(dir_registers[PORT1]) = Output; *(out_registers[PORT1]) = Low;
  *(dir_registers[PORT2]) = Output; *(out_registers[PORT2]) = Low;
  *(dir_registers[PORT3]) = Output; *(out_registers[PORT3]) = Low;
  *(dir_registers[PORT4]) = Output; *(out_registers[PORT4]) = Low;
  *(dir_registers[PORT5]) = Output; *(out_registers[PORT5]) = Low;
  *(dir_registers[PORT6]) = Output; *(out_registers[PORT6]) = Low;
  *(dir_registers[PORT7]) = Output; *(out_registers[PORT7]) = Low;
  *(dir_registers[PORT8]) = Output; *(out_registers[PORT8]) = Low;
}