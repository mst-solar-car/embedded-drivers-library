/**
 * CAN Driver Implementation
 *
 * Authors: Everyone?
 */
#include "../datatypes.h"
#include "interface.h"
#include "../utils/queue/interface.h"
#include "config.h"


/* "Private" Variables for use only in this driver (helps for unit testing) */
static void(*_can_controller_setup_func)(spi_bus, io_pin, io_pin, uint16_t[], uint16_t[]) = NULL;
static void(*_can_controller_poll_func)(void) = NULL;
static void(*_can_controller_transmit_func)(can_message*) = NULL;


/* Queue for holding received messages */
static Queue* _queue;

/* Filters and Masks */
uint16_t filters[7];
uint16_t* filters_ptr;

uint16_t masks[3] = { 2, 0x7FF, 0x7FF};
uint16_t* masks_ptr;

/* Variable used for creating messages before calling can_transmit() */
can_message* can_new_msg;
can_message _can_msg_for_sending;


/**
 * Setups the CAN Drivers
 */
void can_setup(spi_bus bus, io_pin cs_pin, io_pin int_pin)
{
  /* Perform CAN Controller Setup */
  _can_controller_setup_func(bus, cs_pin, int_pin, filters, masks);
}


/* Set which filters and masks to use */
void __can_accept(
  uint16_t filter1, uint16_t filter2, uint16_t filter3,
  uint16_t mask
)
{
  /* Save filters and masks into an array for sending to can controller setup */
  *filters_ptr++ = filter1;
  *filters_ptr++ = filter2;
  *filters_ptr++ = filter3;

  if (filters_ptr > &(filters[6]))
    filters_ptr = &(filters[1]);

  /* Save the mask */
  *masks_ptr++ = mask;

  if (masks_ptr > &(masks[2]))
    masks_ptr = &(masks[1]);
}


/**
 * Pulls a Message from the Receive Queue and returns it to the user
 */
can_message* can_receive(void)
{
  _can_controller_poll_func(); /* Check for missed interrupts on the CAN Controller */

  can_message* msg = (can_message*)Queue_Pop(_queue);
  if (msg == NO_MESSAGE)
    return (can_message*) NO_MESSAGE;

  /* Avoid Stupid Messages */
  if (msg->address == 0x00)
    return (can_message*) NO_MESSAGE;

  return msg;
}


/**
 * Transmits a message over the CAN bus (or queues it on the CAN Controller)
 */
void can_transmit(void)
{
  _can_controller_transmit_func(&_can_msg_for_sending);

  /* Clear the message so the user can create a new one */
  uint8_t i;
  _can_msg_for_sending.address = 0x00;
  _can_msg_for_sending.status = 0x00;

  for (i = 0; i < CAN_DATA_LENGTH; i++)
    _can_msg_for_sending.data.data_u8[i] = 0x00;

  /* Check for missed messages */
  _can_controller_poll_func();
}



/* CAN Driver Initialization (called automagically or for unit testing) */
void can_initialization(
  void(*can_setup_func)(spi_bus, io_pin, io_pin, uint16_t[], uint16_t[]),
  void(*can_poll_func)(void),
  void(*can_transmit_func)(can_message*)
)
{
  _can_controller_setup_func = can_setup_func;
  _can_controller_poll_func = can_poll_func;
  _can_controller_transmit_func = can_transmit_func;

  /* Iniitalize Receive Queue */
  _queue = Queue_New(can_message);

  can_new_msg = &_can_msg_for_sending;

  filters[0] = 6;
  filters_ptr = &(filters[1]);

  masks[0] = 2;
  masks_ptr = &(masks[1]);
}




/* Used so the CAN Controller can place a message in the receive buffer */
void __can_add_to_receive_queue(can_message* msg)
{
  if (msg->address == 0x00 || msg->status != CAN_OK)
    return;

  /* Push into the queue */
  Queue_Push(_queue, msg);
}