/**
 * Unit Tests for CAN Drivers
 *
 * Author: Michael Rouse
 */
#ifdef GROUP
#undef GROUP
#endif

#define GROUP CAN

#define CAN_CS_PIN  P1_5
#define CAN_INT_PIN P1_6
#define CAN_INT_BIT pinBit(CAN_INT_PIN)

/**
 * SETUP
 */
TEST(setup)
{
  can_setup(CAN_CS_PIN, CAN_INT_PIN);
  TEST_ASSERT_TRUE_MESSAGE(was_can_setup, "Variable 'was_can_setup' was not set to True in the can_controller_setup() function");
}

/**
 * Send
 */
TEST(transmit)
{
  uint8_t i;
  bool result;

  can_setup(CAN_CS_PIN, CAN_INT_PIN);

  // Create the message and send it
  can_new_msg->address = 0x666;
  for (i = 0; i < 8; i++)
    can_new_msg->data.data_u8[i] = i + 10;

  result = can_transmit(); // Send

  TEST_ASSERT_TRUE_MESSAGE(result, "can_transmit() did not return Success");
  TEST_ASSERT_NOT_EQUAL_MESSAGE(0x00, *can_tx0_buf, "can_tx0_buf did not have data in it after calling can_transmit()");
}

/**
 * Send with Busy
 */
TEST(transmitWhileBusy)
{
  uint8_t i;
  bool result;

  can_setup(CAN_CS_PIN, CAN_INT_PIN);

  // Create the message and send it
  can_new_msg->address = 0x666;
  for (i = 0; i < 8; i++)
    can_new_msg->data.data_u8[i] = i + 10;

  // Set busy flag and try sending
  is_can_busy = True;
  result = can_transmit();
  TEST_ASSERT_FALSE_MESSAGE(result, "can_transmit() did not return Failure when forced to be busy using 'is_can_busy=True'");

  // Remove the busy flag and try sending again
  is_can_busy = False;
  result = can_transmit();
  TEST_ASSERT_TRUE_MESSAGE(result, "can_transmit() did not return Success when force busy was removed");
}

/**
 * Receiving No message
 */
TEST(receiveNothing)
{
  can_setup(CAN_CS_PIN, CAN_INT_PIN);

  can_message* msg = can_receive();

  TEST_ASSERT_TRUE_MESSAGE((msg == NOTHING), "can_receive() did not return NOTHING when no message has been received");
}

/**
 * Poll for missed message
 */
TEST(pollMissedMessage)
{
  can_setup(CAN_CS_PIN, CAN_INT_PIN);

  can_transmit(); // Won't transmit anything but will poll for a missed interrupt

  setRegisterBitLow(p1_in, CAN_INT_BIT);
  can_message* msg = can_receive();

  TEST_ASSERT_TRUE_MESSAGE((msg != NOTHING), "can_receive() returned NOTHING when a message should have been received");
}


/**
 * Interrupt
 */
TEST(interrupt)
{
  can_message* msg;
  can_setup(CAN_CS_PIN, CAN_INT_PIN);

  // Confirm that the interrupt was configured
  TEST_ASSERT_BITS_LOW_MESSAGE(CAN_INT_BIT, *p1_dir, "P1_6 not set as input after attachInterrupt");
  TEST_ASSERT_BITS_HIGH_MESSAGE(CAN_INT_BIT, *p1_ies, "BIT6 not High in p1_ies reg after attachInterrupt");
  TEST_ASSERT_BITS_LOW_MESSAGE(CAN_INT_BIT, *p1_ifg, "BIT6 not Low in p1_ifg after attachInterrupt");
  TEST_ASSERT_BITS_HIGH_MESSAGE(CAN_INT_BIT, *p1_ie, "BIT6 was not high in p1_ie after attachInterrupt");

  // Make sure no messages
  msg = can_receive();
  TEST_ASSERT_TRUE_MESSAGE((msg == NOTHING), "can_receive() returned a message when it should not have (before interrupt simulation)");

  // Trigger interrupt
  setRegisterBitLow(p1_in, CAN_INT_BIT);
  setRegisterBitHigh(p1_ifg, CAN_INT_BIT); // Set IFG high (meaning an interrupt occured)
  _dispatchInterrupt(NULL, pinPort(CAN_INT_PIN));
  setRegisterBitHigh(p1_in, CAN_INT_BIT);

  // Check for message (to see if interrupt occured)
  msg = can_receive();
  TEST_ASSERT_TRUE_MESSAGE((msg != NOTHING), "can_receive() returned NOTHING after an interrupt should have been simulated");
}




GROUP_SETUP()
{
  *can_tx0_buf = 0x00; *can_tx1_buf = 0x00; *can_tx2_buf = 0x00;
  *can_rx0_buf = 0x00; *can_rx1_buf = 0x00;

  *p1_ies = 0x00; *p1_dir = 0x00; *p1_ifg = 0x00; *p1_ie = 0x00;

  setRegister(p1_in, LOW);
}


// Run all CAN tests
GROUP_RUNNER()
{
   // Create Fake Registers
  alloc2(can_tx0_buf); alloc2(can_tx1_buf); alloc2(can_tx2_buf);
  alloc2(can_rx0_buf); alloc2(can_rx1_buf);

  RUN(setup);
  RUN(transmit);
  RUN(transmitWhileBusy);
  RUN(receiveNothing);
  RUN(pollMissedMessage);
  RUN(interrupt);
}
